# Intuition

The first think you should ask yourself is how can i descover the product of all the other elements beside itself. The answer (even tho is simple) is to make the product of the previos elements and the next elements then multiply them.

# Approach

## With extra memory used

Precompute sufix and prefix sum(product but i called it sum to be more clearer what base algorithm it uses). If not know alredy you should first tackle implementing a class based on that with O(1) get betwin 2 points (amortizate time).
After computing them, for each index just make the product of the prefix before it and sufix after it (for index 0 prefix will become 1 and for index length - 1 sufix will become 1)

## With no extra memory (beside the answer itself)

Firstly compute the prefix array. After that if you think you can see that you don t need to worry about the sufix sum bcz you can compute it while passing again through the prefix from the end. With it precompute you just need to be careful only for the index 1 to not multiply by the index -1 (index out of bound)

!! JS is quercky and -1*0 will result in -0 so that raises the problem of conflict betwin solutions bcz under the hood 0 != -0.
For that i build an util function for separation of concerns.

# Complexity

- Time complexity: O(n)
- Space complexity: O(n) if response taken in consideration else is O(1)

# Code

```javascript []
/**
 * @param {number[]} nums
 * @return {number[]}
 */
export const normalizeZero = (n) => Object.is(n, -0) ? 0 : n;

export const productExceptSelf = (nums) => {
  let res = [];
  let multiplier = 1;
  for (let num of nums) {
    multiplier *= num;
    res.push(multiplier);
  }

  multiplier = 1;
  for (let i = nums.length - 1; i >= 0; i--) {
    const left = i > 0 ? res[i - 1] : 1
    res[i] = normalizeZero(left * multiplier);
    multiplier *= nums[i];
  }

  return res;
};
```
