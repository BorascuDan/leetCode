# Intuition

 On the first look you should be able to realize the best approach is to use 2 pointers, each one at a specific end and if they differ then the input is not a palindrom. There are 2 ways to solve this problem, first to use the 2 pointer and for both l and r while they are not alphanumerical just skip till you are at an alphanumerical value and compare them. This one is the best approach but out of my experience is way more readable for future developers to quickly understand what my solution does (in my opinion at least).

# Approach

  First we normalize the string. Use to lower case to make every char lower case and use a regex to replace all alphanumerical chars. This kind of simple regex should be really understandable even for developers at the start of the work. Then you as a developer are tasked to firstly think what edge case there might be. We have no problem to use methods to normalize because the constrains are in the range of 10^5 chars, each method is in worst case O(n) so the overall complexity will just rise to O(4n) with is also O(n). The next edge case possible is for the string to contain trailing spaces, so we should also add a .trim() to remove any of that. After that just use a 2 pointers approach as described above to find the solution.

# Complexity

- Time complexity: O(n) -> O(4*n) but it is amortize to O(n)
- Space complexity: O(n) -> while the solution consumes extra memory in real world is not that important because the memory is de-allocated fairly fast. As a developer you always have to think about tradeoff readability vs optimization.

# Code

```javascript []
/**
 * @param {string} s
 * @return {boolean}
 */
export const isPalindrome = (s) => {
  const str = s.trim().toLowerCase().replace(/[^0-9a-z]/g, "");
  let [left, right] = [0, str.length - 1];
  console.log({ str })
  while (left < right) {
    if (str[left] !== str[right]) return false;

    left += 1; right -= 1;
  }

  return true;
};
```
