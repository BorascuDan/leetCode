# Intuition

When i first read it I felt confused. (!!free Tip don t give up). Then i started building the solution from ground up. The only think that i felt could be seen before actually typing and thinking is that we should use a sliding window.

# Approach

I was thinking of possible edge cases. First think visible to me was that if t length is greater or if t is an empty string then the result should be an empty string. That optimizes the solution by making m a constant that is all the time through the solution at most n (will explain in complexity part why that matters). After that the first step of the actual solution is to build a frequency map for t chars. Having the frequency built, it should be clear if you think about it that we need to check only the numbers of chars that have the same frequency AKA count how many distinc chars there are (by counting i mean take the size of the map). After that you make a map for the current chars frequency in s. If a character matches the frequency from t we increment the number of chars that check the condition. Then for when you shrink the window check the length if it s smaller to update result. Then just see if the condition for the char at the l pointer still matches, if it s smaller decrement the count of checked frequency. In the end check if the min length is infinity. if it is there were no sliding window involved aka no substring contained all the chars from t. Otherwise just use slice with the result saved earlier.

# Complexity

- Time complexity: O(n)
- Space complexity: O(n)

Why is O(n), well after our first if we know that m is at much n length. In the worst case if it is the solution will become O(n + n) = O(2 * n) and that is just plain old O(n). So even tho logically is O(n + m) it actually rounds to O(n) (both memory and space)

# Code

```javascript []

/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
export const minWindow = (s, t) => {
  if (t.length > s.length || t === "") return ""

  let freq = {};
  for (let char of t) freq[char] = (freq[char] ?? 0) + 1;

  const needed = Object.keys(freq).length;
  let have = 0;
  let res = [-1, -1];
  let minWindow = Infinity;
  let l = 0;
  let curent = {};

  for (let r = 0; r < s.length; r++) {
    curent[s[r]] = (curent[s[r]] ?? 0) + 1;
    if (freq[s[r]] && curent[s[r]] === freq[s[r]]) have += 1;

    while (have === needed) {
      if (minWindow > r - l) {
        res = [l, r];
        minWindow = r - l;
      }

      curent[s[l]] -= 1;
      if (freq[s[l]] && curent[s[l]] < freq[s[l]]) have -= 1;
      l += 1;
    }
  }

  return minWindow === Infinity ? "" : s.slice(res[0], res[1] + 1);
};
```
